# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

import pyquery

from django.conf import settings
from django.urls import reverse

from crashstats import productlib
from crashstats.crashstats import models
from crashstats.crashstats.tests.test_views import BaseTestViews
from crashstats.supersearch.models import SuperSearchUnredacted


class TestViews(BaseTestViews):
    def test_exploitability_report(self):
        models.BugAssociation.objects.create(
            bug_id=111111111, signature="FakeSignature 1"
        )
        models.BugAssociation.objects.create(
            bug_id=222222222, signature="FakeSignature 3"
        )
        models.BugAssociation.objects.create(
            bug_id=101010101, signature="FakeSignature"
        )
        url = reverse("exploitability:report")

        queried_versions = []

        def mocked_supersearch_get(**params):
            assert params["product"] == ["WaterWolf"]
            queried_versions.append(params.get("version"))
            assert params["_aggs.signature"] == ["exploitability"]
            assert params["_facets_size"] == settings.EXPLOITABILITY_BATCH_SIZE
            assert params["exploitability"]
            assert params["_fields"]
            facets = [
                {
                    "count": 229,
                    "facets": {
                        "exploitability": [
                            {"count": 210, "term": "none"},
                            {"count": 19, "term": "low"},
                        ]
                    },
                    "term": "FakeSignature 1",
                },
                {
                    "count": 124,
                    "facets": {
                        "exploitability": [
                            {"count": 120, "term": "none"},
                            {"count": 1, "term": "high"},
                            {"count": 4, "term": "interesting"},
                        ]
                    },
                    "term": "FakeSignature 3",
                },
                {
                    "count": 104,
                    "facets": {
                        "exploitability": [
                            {"count": 93, "term": "low"},
                            {"count": 11, "term": "medium"},
                        ]
                    },
                    "term": "Other Signature",
                },
                {
                    "count": 222,
                    "facets": {
                        "exploitability": [
                            # one that doesn't add up to 4
                            {"count": 10, "term": "null"},
                            {"count": 20, "term": "none"},
                        ]
                    },
                    "term": "FakeSignature",
                },
            ]
            return {"facets": {"signature": facets}, "hits": [], "total": 1234}

        SuperSearchUnredacted.implementation().get.side_effect = mocked_supersearch_get

        response = self.client.get(url, {"product": "WaterWolf"})
        assert response.status_code == 302

        user = self._login()
        response = self.client.get(url, {"product": "WaterWolf"})
        assert response.status_code == 302

        group = self._create_group_with_permission("view_exploitability")
        user.groups.add(group)
        assert user.has_perm("crashstats.view_exploitability")

        # unrecognized product
        response = self.client.get(url, {"product": "XXXX"})
        assert response.status_code == 404

        # unrecognized version
        response = self.client.get(url, {"product": "WaterWolf", "version": "0000"})
        assert response.status_code == 400

        # valid version but not for WaterWolf
        response = self.client.get(url, {"product": "WaterWolf", "version": "1.5"})
        assert response.status_code == 400

        # if you omit the product, it'll redirect and set the default product
        response = self.client.get(url)
        assert response.status_code == 302

        assert response["Location"].endswith(
            url + "?product=%s" % productlib.get_default_product().name
        )

        response = self.client.get(url, {"product": "WaterWolf", "version": "19.0"})
        assert response.status_code == 200

        doc = pyquery.PyQuery(response.content)

        # We expect a table with 3 different signatures
        # The signature with the highest high+medium count is
        # 'Other Signature' etc.
        tds = doc("table.data-table tbody td:first-child a")
        texts = [x.text for x in tds]
        assert texts == ["Other Signature", "FakeSignature 3", "FakeSignature 1"]

        # The first signature doesn't have any bug associations,
        # but the second and the third does.
        rows = doc("table.data-table tbody tr")
        texts = [[x.text for x in doc("td.bug_ids_more a", row)] for row in rows]
        expected = [[], ["222222222"], ["111111111"]]
        assert texts == expected

        assert queried_versions == [["19.0"]]
        response = self.client.get(url, {"product": "WaterWolf"})
        assert response.status_code == 200
        assert queried_versions == [["19.0"], None]
